\documentclass[]{article}
\usepackage[table]{xcolor}
\usepackage[utf8]{inputenc}
\usepackage{natbib}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{hyperref}

\usepackage{listings}
\usepackage{xcolor}
\usepackage{multicol}
\usepackage{graphics}



\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{1,1,1}

\lstdefinestyle{mystyle}{
	backgroundcolor=\color{backcolour},   
	commentstyle=\color{codegreen},
	keywordstyle=\color{blue},
	numberstyle=\tiny\color{codegray},
	stringstyle=\color{codepurple},
	basicstyle=\ttfamily\footnotesize,
	breakatwhitespace=false,         
	breaklines=true,                 
	captionpos=b,                    
	keepspaces=true,                 
	numbers=left,                    
	numbersep=5pt,                  
	showspaces=false,                
	showstringspaces=false,
	showtabs=false,                  
	tabsize=2
}

\lstset{style=mystyle}











\geometry{
	a4paper,
	total={170mm,257mm},
	left=20mm,
	top=20mm,
}

%opening
\title{Progetto di Algoritmi Avanzati  	
		\\ \large Capacitated Vehicle Routing Problem 
		 \\  Algoritmi: Costruttivi, a 2 Fasi e Genetici}
	 

\author{Giulio Pilotto - Matricola:1140718}

\date{Luglio 2019}

	

\begin{document}
	



\maketitle


\begin{abstract}

Questo elaborato presenta il progetto di Algoritmi Avanzati sottomesso al prof. Bresolin dell'Università di Padova.
Il progetto richiede di implementare almeno 2 algoritmi che risolvono istanze di : Capacitated Vehicle Routing Problem.
Nel seguente elaborato oltre ad implementare i 2 algoritmi richiesti , il primo come metodo costruttivo; Clarke and Wright e il secondo come metodo a 2 fasi:ClusterFirst - Route Second per il quale sono state implementate due tecniche di routing: Nearest-Neighbourn e Dijkastra.
Sono stati implementati altri 2 algoritmi uno che cade sempre nella classe dei metodi a 2 fasi: RouteFirst - ClusterSecond, e un altro che cade nella categoria degli algoritmi metauristici detti anche algoritmi genetici.
Inoltre, è stato implementato un metodo di selezione dei centroidi che tiene conto sia della distanza dal deposito sia della distanza inter-cluster.
Tutti gli algoritmi sono stati testati sulle 16 istanze fornite dalla libreria TSPLIB95.
I risultati confermano che a fronte di una minore accuratezza di una soluzione rispetto all'ottimo ma una maggiore richiesta di risorse in termini di tempo, possono portare a soluzioni ben approssimate.
In particolare scegliere i centrodi con il metodo RadiusRadar permette di guadagnare qualche decimo a fronte di un tempo inore.
Le soluzioni posso essere migliorate attrverso gli algoritmi genetici che fungono da esploratori di uno spazion locale.

\end{abstract}

\section{Introduzione}
Con la nascita dei nuovi servizi per il cliente, che danno assistenza e portao i prodotti direttamente sulla soglia di casa (es:Amazon Prime), la gestione della logistica predilige gran parte degli investimenti.
Questo fatto diventa ancor più importante se diamo un occhiata ai dati forniti dall' Associazione Nazionale Filiera Industria Automobilistica (ANFIA) nel 2017 \ref{fig:ITA28} , dove viene sottolineato che i camion movimentano l'80$\%$ delle merci su terra \cite{ANFIA2017}. 
Gli investimenti non riguardano solo le strutture o gli strumenti fisici, ma soprattutto i software per la gestione e l'ottimizzazione  della distribuzione dei beni.
Grazie all'informatizzazione dei processi da parte del nuovo programma di industrializzazione chiamato "industria 4.0", si può godere di banche dati ricche ed aggiornate, attraverso le quali, possono essere implementate tecniche di ricerca operativa e ottimizzazione.

Il Vehicle Routing Problem \textbf{(VRP)}  è un classe reale di problemi di soddisfacimento di vincoli, in inglese detto anche Constraint Satisfaction Problem \textbf{(COP)}.
Alla fine degli anni cinquanta Dantzig and Ramser hanno formalizzato il problema \cite{dispatching} che riguarda la distribuzione di benzina da un deposito princiapale ad un grande numero di stazioni di servizio.
Da quel momento l'interesse nei problemi VRP è evoluto da un piccolo gruppo di matematici ad un grande gruppo di ricercatori da differenti discipline ancora oggi coinvolti.


VRP consiste nell'ottimizzare l'uso di un insieme di veicoli per prelevare della merce da uno o più depositi e consegnarle presso dei clienti che richiedono una certa quantità di merce.
Le stazioni , i depositi sono distribuiti in uno spazio rappresentato da delle distanze. I mezzi si spostano percorrendo tali distanze, che possono essere rappresentate in maniera diversa.
La maggioranza the problemi reali sono sepsso più complessi del classico VRP. Quindi in pratica VRP è aumentato con dei vincoli, come ad esempio la capacità del veicolo: dove ogni veicolo è caratterizzato da una capacità limitata di carico delle merci, passando quindi da VRP a \textbf{Capacitated - VRP}.
Gli obiettivi sono molteplici:
\begin{itemize}
	\item Minimizzare dei costi di trasporto (istanze percorse, consumo di carburante)
	\item Minimizzare il numero di veicoli
	\item Rispettare il vincolo di capacità imposto  sui veicoli.
	\item Assegnare un percorso ad ogni singolo veicolo.
\end{itemize}


\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.50]{images/ITA28.png}
	\caption{ Italia, traffico merci su strada, ANFIA su dati ISTAT 2017 }
	\label{fig:ITA28}
\end{figure}

VRP è un problema di ottimizzazione combinatoria NP hard,che può essere risolto esattamente trovando l'ottimo solo per piccole istanze del problema. In ogni caso gli approcci euristici che non garantiscono l'ottimalità, forniscono ottimi risultati in pratica.
Negli ultimi 30 anni sono stati applicati anche dei metodi meta-euristici che hanno mostrato una nuova direzione alla ricerca sulla famiglia di problemi VRP.
In questo elaborato vengono prese in esame le istanze fornite dalla libreria TSPLIB95\cite{TSPLIB95}.

Sono stati implementati i seguenti metodi per risolvere le istanze CVRP:
\begin{itemize}
	\item Metodo Costruttivo: Clarke and Wright
	\item Metodo a due fasi:
	\begin{itemize}
		\item Cluster-First Route-Second: Fisher and Jaikumar
		\item Route-First Cluster-Second: Dijkastra
	\end{itemize}
	\item Meta-euristiche: Algoritmi Genetici
\end{itemize}

\newpage
\subsection{Rappresentazione del problema} \label{RappProb-sec}
CVRP è la versione più comune dei problemi VRP. Ciò che caratterizza queta tipologia di problemi è il fatto che l servizio è di semplice ocnsgna senza raccolta.
Inoltre le richieste dei clienti sononote a pripri e deterministiche e devono essere soddisfatte da un solo veicolo; tuti i veicoli sono identici e basati su un singolo deposito centrale. Gli unici vincoli imposti riguardano le capacità di veicoli. L'obbiettivo è minmizzare il costo totale di servizio che può essere una funzione del numero dei route, della lunghezza complessiva o del tempo di percorrenza.
Consideraimo ora la rappresentazione su grafo di questo problema.
\begin{itemize}
\item Sia \emph{G = (V,A)} un grafo completo dove \emph{V = \{0,...,n\}} è l'insieme dei vertici e \emph{A} quello degli archi.
\item I vertici \emph{i = i,...,n} corrispondono ai clienti, mentre il vertice 0 corrisponde al deposito. 
\item Ad ogni arco \emph{(i,j) $\in$ A} è associato un costo non negativo \emph{$c_{i,j}$}, che rappresenta il costo di trasferimento dall'indice \emph{i} all'indice \emph{j}
\item In genere l'uso di loop non è consentito e ciò è imposto definendo \emph{$c_{i,j}$=+$\infty$}  \emph{ $\forall$ i $\in$ V}.Nella nostra implementazione invece abbiamo definito  \emph{$c_{i,j}$=0}  \emph{ $\forall$ i $\in$ V}.
\item Dato un insieme \emph{ S $\subseteq$ V}, \emph{d(S)} denota la richiesta complessiva dei clienti in \emph{S: d(S) = $\sum_{s \in S} d_{s} $}.
\item  Indicando con \emph{r} una \emph{route}, \emph{d(r)} denota la richiesta complessiva dei vertici da esso visitati.
\item Un insieme \emph{K} di veicoli è disponibile presso il deposito. Tali veicoli sono tutti identici di capacità \emph{C}; una semplice condizione di ammissibilità del problema richiede \emph{$ d_{i} \leq C $ $ \forall i \in V \setminus \{0\} $}.
\item Ogni veicolopuò percorrere al più un \emph{route}.
\item Si assume che \emph{$K \geq K_{min}$} dove \emph{$K_{min}$} è il minimo numero di veicoli necessari per servire tutti i clienti.
\item In questa implementazione utilizziamo il numero minimo di veicoli necessari per servire tutti i vertici in \emph{S}, pari al  \emph{lower bound}  \emph{$ K_{min} =d(S)/C $}
\end{itemize}
Gli obbiettivi ed i vincoli già citati nella sezione precedente vengono ora descritti in maniera formale, associando ai vincoli il modello matematico che li esprime.

\[M_{i,j}^k = \left\{
\begin{array}{lr}
1 :sse (i,j) \in A \wedge M_{i,j} \in  r(k) \mid k \in K \wedge r \in route\\
0 :altrimenti
\end{array}
\right.
\]

Definiamo inoltre \emph{$q_{i}$} la richiesta associata ad ogni cliente visitato da un circuito e \emph{$C_{k}$} la capacità del veicolo \emph{$k \in K$}.

La funzione obbiettivo descritta formalmente è la seguente:

\begin{equation} \label{objF}
\min \sum_{k \in K} \sum_{(i,j) \in A} c_{i,j} \cdot M_{i,j}^k 
\end{equation}



al quale sono applicati i seguenti vincoli:

\begin{equation} \label{v1}
 \sum_{k \in K} \sum_{j \in V} M_{i,j}^k = 1 \ \forall i \in V
\end{equation}

\begin{equation} \label{v2}
\sum_{i \in V} d_{i} \sum_{j \in V} M_{i,j}^k \leq C_{k} \ \forall k \in K
\end{equation}

\begin{equation} \label{v3}
\sum_{j \in V} M_{0,j}^k = 1 \ \forall k \in K
\end{equation}

\begin{equation} \label{v4}
\sum_{i \in V} M_{i,h}^k - \sum_{j \in V} M_{h,j}^k = 0 \ \forall k \in K ,\  \forall h \in V
\end{equation}

\begin{equation} \label{v5}
\sum_{i \in V} M_{i,0}^k = 1 \ \forall k \in K
\end{equation}




La funzione obbiettivo \ref{objF}, minimizzare il costo dei km totali percorsi da ogni singolo veicolo.
Il vincolo \ref{v1} impone che ogni cliente deve essere servito da un solo veicolo.
Il vincolo \ref{v2} assicura che il limite sulla capacità dei veicoli venga rispettato.
I vincoli \ref{v3}, \ref{v4} , \ref{v5} sono vincoli che impongono ad ogni veicolo di partire dal deposito il nodo 0, e collegarsi ad un nodo h, unico per ogni route,e di ritornare al deposito, indicato nella nostra implementazione sempre dal nodo 0. Questi vincoli definiscono la struttura della route.
\textbf{Questa sezione va rivista }

\section{Related Works}
Quasi tutti i metodi implementati sono euristici perchè nessuno degli algoritmi può garantire di trovare una soluzione ottima per grandi istanze, in un limite di tempo computazionale ragionevole.
Un approccio euristico non esplora l'intero spazio di ricerca, piuttosto cerca di trovare una soluzione basandosi sulle informazioni che ha sul problema.
Le euristiche che risolvono istanze CVRP sono identificati come metodi costruttivi (\textbf{costructive}) e di raggruppamento \textbf{()clustering)}.
I metodi costruttivi costruiscono una soluzione gradualmente,aggiornando continuamente l'informazione che riguarda il costo, ma potrebbe non contenere nessuna fase di miglioramento o di ottimizzazione della soluzione.
Gli algoritmi costruttivi più famosi sono: Clarke and Wright's savings algorithm \cite{CK1}, \cite{CK2} , \cite{CK3} , Matching based algorithm e Multi-route improvement heuristic \cite{CK3}.
I metodi di clustering, risolvono il problema in due fasi , ed è per questo che vengono chiamati metodi a 2 fasi.  l'approccio route-first cluster second è caratterizzato dalle due fasi seguenti:
\begin{itemize}
\item \textbf{Fase 1 - Clustering:} Un algoritmo di clustering viene utilizzato per raggruppare i clienti in cluster da dare in pasto alla seconda fase
\item \textbf{Fase 2- Routing} Nella seconda fase, per ogni cluster creato nella prima fase viene ricercata la strada più corta sfruttando tecniche di ottimizzazione.
\end{itemize}
Alcuni famosi algoritmi a due fasi sono: Petal algortihm \cite{petal}, Sweep algorithm \cite{sweep} e Fisher and Jaikumar \cite{FJ}.
Questo studio investiga e compara le performance dei metodi costruttivi e di raggruppamento per risolvere istanze di CVRP.
In particolare, nell'algoritmo di Fisher and Jaikumar, è stato implementato un algoritmo per la selezione dei centroidi chiamato Radar-Radius.Questo  massimizza la distanza tra centroidi (inter-centroid distance) e la distanza tra i centroidi e il deposito in modo da garantire la migliore copertura, a seconda della distribuzione del deposito e dei clienti.
Questo algoritmo è stato implementato scegliendo un deposito per ogni istanza in TSPLIB95,solitamente il deposito con id identificativo 1.
Sono stati usati due metodi diversi per realizzare il routing tra i clienti di uno stesso cluster: Nearest Neighbourn e Dijkastra.
I raggruppamenti formati dai metodi di clustering sono successivamente ottimizzate da metodi metaeuristici, in questa implementazione viene presentato un Algoritmo Genetico  \textbf{(GA)} \cite{GA}, il quale è un famoso approccio utilizzato per risolvere istanze Travelling Salesman Problem (TSP).
\textbf{Bensi i metodi costruttivi generano già delle soluzioni molto vicino all'ottimo, l'algoritmo Genetico è applicato anche al Savings algorithm per avere una misura di performance.}




\section{Materiali e Metodi}
Lo sviluppo di algoritmi euristici è mirato a fornire una soluzione di buona
qualità ad un problema difficile con un limitato tempo di calcolo. Nella
maggior parte dei casi infatti, non si ha il tempo neccessario per applicare
metodi esatti.
In questo senso ci vengono in aiuto gli algoritmi euristici, che im-
piegano tempi di calcolo relativamente ristretti per fornire soluzioni di
buona qualità. Laport e Semet hanno fornito una classificazione di que-
sti metodi, distinguendo tra euristici classici e metaeuristici; la differen-
za principale sta nel livello di profondità che questi metodi raggiungono
nell’esplorazione dello spazio delle soluzioni. Mentre gli euristici classici
ottengono buone soluzioni con limitati tempi di calcolo, i metaeuristici
approfondiscono la ricerca della soluzione ottima nelle zone più promet-
tenti dello spazio delle soluzioni, implementando sofisticate regole di ri-
cerca e di ricombinazione dei risultati parziali ottenuti. Questi metodi,
seppur impiegando un tempo di risoluzione maggiore, ottengono soluzio-
ni migliori rispetto ai metodi classici. Rinviamo la trattazione di questi
ultimi al capitolo successivo, focalizzando ora l’attenzione sugli euristici
classici.
\subsection{Metodi Euristici Costruttivi}
Un metodo in questa categoria costruisce le strade per i veicoli mentre cerca di minimizzare la distanza percorsa.
L'algoritmo di Savings di Clarke and Wright \cite{CK1}, trova una soluzione utilizzando un'euristica, quindi il risultato non è sempre la soluzione ottima, ma dovrebbe risultare mol+to vicina all'ottimo con un risparmio di tempo computazionale elevato rispetto ad un algoritmo brute force.


\subsubsection{Algoritmo di Savings di Clarke and Wright}
L'algoritmo si basa su una coda ordinata di risparmi, detta anche \emph{savings list}.
Ogni record della coda è ottenuto collegando due \emph{route} che non hanno nodi in comune eccetto il deposito.
Dall'unione si ottiene una singola \emph{route}, come mostrato nella figura \ref{fig:saving}, dove il nodo 0 rappresenta il deposito.

\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.25]{images/saving.png}
	\caption{Inizialmente nella figura 1(a) i clienti \emph{i} e \emph{j} sono visitati da \emph{route} separate. Un alternativa per visitare i due clienti con la stessa \emph{route} è presentata in 1(b). }
	\label{fig:saving}
\end{figure}

I costi di trasporto calcolati in 1(a) sono:
\begin{equation}
D_{a} = C_{o,i} +C_{i,0} + C_{o,j} + C_{j,0}
\end{equation}

Mentre i costi di trasporto in 1(b) sono:

\begin{equation}
D_{a} = C_{o,i} +C_{i,j} + C_{o,j} 
\end{equation}

Ora il costo di trasporto risparmiato detto \emph{saving distance} per visitare \emph{i} e \emph{j} nella stessa \emph{route} invece che visitarli con due \emph{route} separate è:
\begin{equation}
D_{a} = D_{a} +D_{b} =+ C_{i,0} +  C_{0,j} +  C_{i,j} 
\end{equation}

\paragraph{Sequenziale e Parallelo } \hfill
La distanza risparmiata è direttamente proporzionale alla vicinanza dei clienti e inversamente proporzionale alla vicinanza al deposito.
Più grande è la distanza risparmiata più vicini si troveranno i clienti, e più distanti essi saranno dal deposito.
Le coppie di clienti sono ordiate in ordine decrescente secondo il valore di \emph{savings} che è stato calcolato sulla coppia.
La costruzione delle \emph{routes} parte dal primo record della coda. Quando una coppia \emph{i}  e \emph{j} viene considerata se questa è già presente in una \emph{route} allora si passa alla prossima coppia per l'inserimento.
Ci sono due approcci proposti per l'algoritmo di \emph{savings} \textbf{sequenziale}  e \textbf{parallelo}.
\begin{itemize}
\item Nell'approccio \textbf{sequenziale} se una coppia di cliente non corrisponde con uno dei nodi presenti nella strada, la coppia viene ignorata.
Ogni volta che un cliente è inserito in una \emph{route}, l'algoritmo deve cominciare dall'inizio siccome le combinazioni che non erano disponibili fino a prima dell'inserimento potrebbero essere disponibili ora. Questo approccio crea una \emph{route} alla volta, richiedendo di ripassare la coda di \emph{savings} più di una volta.
Il codice allegato Listing1 descrive come è stato implementato l'algoritmo sequenziale di Clarke and Wright.
La riga 2 e 3, importano il valore di capacità per ogni veicolo, e la rispettiva domanda di ogni cliente. Alla riga 4, la lista di savings viene calcolata attraverso la funzione \emph{calculateSavings} per ogni arco presente nel grafo. Alla riga 8 l'istruzione di controllo \emph{while}, continua a eseguire il codice al suo interno fino a quando tutti i clienti sono assegnati ad una \emph{route} e la lista di  \emph{savings} contiene elementi di risparmio. All'interno del \emph{while} alla riga 9 viene estratta la prima coppia di risparmi,alla riga 10 si inizializza il puntatore \emph{k}, che servirà a scorrere la lista \emph{savings} durate la costruzione della strada \emph{route}, inizializzata poco più sotto alla riga 12, dopo l'istruzione di controllo \emph{if} che controlla che nessun componente della coppia sia già servito da un'altra \emph{route} e che nessuna \emph{route} sia stata già creata. Se il controllo risulta vero allora si passa all'inizializzazione della strada con la coppia selezionata \emph{pair} e quindi si prosegue scorrendo il resto della lista \emph{savings} alla riga 14. Al suo interno i controlli alla riga 18 e 23, garantiscono al mutuale esclusività dei componenti della coppia all'interno della strada che viene estesa dalle rispettive istruzioni 20 e 25; in 21,22 \emph{k} viene azzerato e \emph{save} tolto dalla lista \emph{savings},per ricominciare dall'inizio della lista e scorrere eventuali coppie che adesso potrebbero essere collegate, grazie ai nuovi clienti. Le istruzioni solo uguali in 26,27. Le istruzioni di controllo 19 e 24, garantiscono che il cliente aggiunto rispetti i vincoli di capacità del veicolo, in caso questo.  Infine in 30 si aggiunge la \emph{route} alla soluzione e 31 aggiorna la lista \emph{savings} con la nuova distanza della coppia \emph{pair}. In 32 si ritorna la soluzione.

\item  L'approccio \textbf{parallelo} crea più \emph{routes} contemporaneamente.Quando una coppia di clienti è presa in considerazione, viene confrontata con tutte le \emph{routes} che sono già state generate fino a quel momento.
Se la coppia viene inserita in una route, tutte le \emph{routes} generate fino ad ora vengono confrontate per trovare possibili \emph{route} da unire ulteriormente con attraverso un \emph{merge}. Altrimenti,se la coppia di clienti non corrisponde con nessuna \emph{route},allora una nuova \emph{route} viene create, questa nell'approccio sequenziale invece verrebbe scartata. Nella versione parallela la lista dei \emph{savings} viene visitata una sola volta per tutta la sua lunghezza.
Nel codice Listing2 Dalla riga 2 alla riga 6 le istruzioni sono identiche al codice Listing 1 già presentato. Dalla riga 7 invece si differenzia, in quanto per ogni cliente viene creata una strada: deposito $\rightarrow$ cliente $\rightarrow$ deposito. In 0 il ciclo \emph{for} si occupa di scorrere la lista. Al suo intenro a riga 10 si estrae la tupla che forma la coppia di clienti che appartengono al risparmio. 11,12 e 13 inizializzano a \emph{null} tre di appoggio contenitori \emph{route}. Una volta estratti i clienti, si scorrono tutte le \emph{routes} come in 14, il controllo in 15 si controlla se una \emph{route} passa per \emph{i}, quando questa viene trovata, viene allocata sia in \emph{routeA} in 16, la stessa cosa viene fatta per \emph{j} in 18, 19 con  \emph{routeB}. Il senso di questa doppio allocazione viene si spiega nella righe successive: in 22 si verifica se  \emph{routeA} e \emph{routeA} hanno valori diversi, siccome tutti i clienti hanno una strada assegnata, \emph{routeA} e \emph{routeB} saranno sicuramente diverse da \emph{null} di conseguenza si controlla in 21 se \emph{i} e \emph{j} provengono da strade diverse. In caso positivo si controlla se i componenti della \emph{routeA} e i componenti della \emph{routeB}  rispettano i vincoli di capacità, come descritto in riga 22.Se anche questo controllo viene passato con successo, allora si passa al metodo fondamentale di questo algoritmo, \emph{il Merge}	riga 23.
Questo metodo si preoccupa di capire se i due clienti presenti nelle due diverse \emph{route}, stanno in testa o in coda alla \emph{route}, di conseguenza unisce le due strade importando i clienti nella \emph{routeA} o nella \emph{routeB} a seconda dell'ordine dato da \emph{save}. In 24 si rimuove da \emph{routes} la \emph{route} che è stata copiata e in 26 si ritorna la soluzione.
\end{itemize}
\textbf{
La differenza sostanziale tra i due metodi è la seguente: il metodo sequenziale tende a generare una \emph{route} unica molto grande, e le \emph{route} seguenti invece sono più piccole. Mentre il metodo parallelo tende a formare più strade larghe e quindi riduce il numero finale di \emph{routes}} 

\begin{lstlisting}[language=Python, caption=Implementazione sequenziale di Clarke and Wright  ,escapeinside={(*}{*)}]
def Clarke&Wright_Sequenziale(graph):
	Capacity = graph.getCapacity()
	Demands:list = graph.getDemands()
	savings:list = [calculateSavings (i,j) (* $\forall \ i,j \ \in V \mid i \neq j \wedge i \neq 0 $*)]
	savings.sort(descending)
	routes:list = []
	
	while((*$ \sum_{(r) \in R} \sum_{(v) \in V} ( v \in r) \neq  \ \mid V \mid $*) and len(savings)>0):
		pair = savings.popFirst()
		k=0
		if(pair not served yet and No route is selected):
			route = Route.create(pair)
			
			while(k< lenghtOf(savings)):
				save = savings[k]
				i , j = tuple(save)
				k=k+1
				
				if(route already served i):
					if(checkCustomer(j)):
						route.AddCustomer(j)
						k=0
						savings.remove(save)							
				elif (route already served j):
					if(checkCustomer(i)):
						route.AddCustomer(i)
						k=0
						savings.remove(save)				
					
			routes.append(route)
			savings.update(route)
					
	return routes	
				
\end{lstlisting}


\begin{lstlisting}[language=Python, caption=Implementazione parallela di Clarke and Wright  ,escapeinside={(*}{*)}]
def Clarke&Wright_Parallelo(graph):
	Capacity = graph.getCapacity()
	Demands:list = graph.getDemands()
	list savings = [calculateSavings (i,j) (* $\forall \ i,j \ \in V \mid i \neq j \wedge i \neq 0 $*)]
	savings.sort(descending)
	list routes = []
	routes.append([0 - i - 0])  (* $\forall \ i \ \in V \mid i \neq 0 $*) 
	
	for save in savings:
		i , j = tuple(save)
		routeA = null
		routeB = null
		routeSelected = null
		for route in routes
			if route.served(i):
				routeA = route

			elif route.served(j)
				routeB = route
					    
		if rotues.index(routeA) != routes.index(routeB):
			if routeA.capacity() + routeB.capacity() <= Capacity:
				Merge(routeA,RouteB) 
				routes.remove(RouteA or RouteB)
				
	return routes
\end{lstlisting}

\subsection{Metodi Euristici di Raggruppamento (Clustering)}
I metodi di raggruppamento chiamati anche clustering method, si differenziano dagli altri metodo perchè la risoluzione del probelma è divisi a in due fasi.
\begin{itemize}
\item \textbf{Fase A} Tutti i nodi sono divisi in gruppi (cluster) utilizzando un algoritmo di raggruppamento.
\item \textbf{Fase B} Per ogni gruppo di nodi si utilizza un algoritmo di ottimizzazione per trovare il miglior routing, per servire tutti i nodi del gruppo.
\end{itemize}
Ecco perchè questi algoritmi sono conosciuti anche come algoritmi a 2 fasi.
In questo elaborato vengo presentati i seguenti metodi di raggruppamento a due fasi:
\begin{itemize}
	\item Cluster First,Route Second: Fisher and Jaikumar.
		\begin{itemize}
			\item K centroid selector algoritms :  Random
			\item K centroid selector algoritms :  Radar Radius
			\item General Asignement Problem solver
			\item Routing algoritms: Nearest Neighborn
			\item Routing algoritms: Nearest Neighborn TrackPath		
		\end{itemize}
	\item Route First,Cluster Second: using an auxiliary graph and Dijkastra
\end{itemize}

\subsubsection{Algoritmo di Fisher and Jaikumar} \label{FJ-Sec}
L'algoritmo di \emph{Fisher and Jaikumar} si basa su un'assunzione il numero di veicoli per servire tutti i clienti è dato da input.
Inoltre questo metodo non è applicabile direttamente a VRP che hanno vincoli sulla distanze percorribile da parte del veicolo.
L'algoritmo si svolge in due fasi come abbiamo già detto sopra, in particolare.
\begin{itemize}
 \item Fase 1 - clustering
 	\begin{enumerate}
		\item Selezione dei centroidi: scegli un vertice \emph{k} $\in$ \emph{V} t.c. $\mid K \mid$ = \emph{numero veicoli}.
		\item Calcola il costo di inserimento $c_{i,k}$ del clienti \emph{i} al cluster \emph{k}: \\
		$a_{i,k} = min(c_{o,i} + c_{i,k}+ c_{k,0} + c_{0,k} + c_{k,i} + c_{i,0}) - (c_{0,k} + c_{k,0})  $ $ \forall k \in K$.
		\item Assegnamento Generale: risolvere un \emph{\textbf{G}eneralized \textbf{A}ssignement \textbf{P}roblem} con i costi $c_{i,k} $ $ \forall i \in V , \forall k \in K$, le richieste dei clienti \emph{D} e la capacità prestabilita \emph{C}.
 	\end{enumerate}
 \item Fase 2 - Routing: risolvere un TSP per ogni cluster.
 
\end{itemize}
	
\paragraph{Fase 1.1 - Selezione dei Centroidi} \hfill

In questo elaborato per quanto riguarda la Fase 1.1 sono stati implementati due metodi: La selezione casuale e la selezione utilizzando un algoritmo chiamato dall'autore Radar Radius.

\begin{itemize}
	\item Selezione casuale dei centroidi: vengono scelti casualmente un numero di centroidi uguale al numero di veicoli.
	\item Selezione con Radius Radar Frontier:
\end{itemize}  

\begin{equation}  \label{RR1}
max \sum_{i \in K} c_{i,0} \ 
\end{equation}

\begin{equation} \label{RR2}
c_{i,j} \geq argmax(c_{n,m})/2 \ \ \forall i,j \in K \wedge n,m \in V
\end{equation}


\begin{equation}\label{RR3}
 d_{k} \geq C/2 \ \forall k \in K  
\end{equation}

I centroidi vengono individuati con la lettera \emph{K},in quanto il numero di centroidi corrisponde al numero di veicoli. La funzione di obbiettivo \ref{RR1} massimizza la distanza dei centroidi dal deposito \emph{0}.
Il vincolo \ref{RR2} richiede ai centroidi selezionati, di rispettare una distanza che sia uguale o superiore alla metà della distanza massima tra centroidi e clienti, ovvero la distanza massima tra un centroide e qualsiasi altro cliente nel grafo. \ref{RR3} vincola i centroidi ad avere una richiesta che sia maggiore della metà della capacità del veicolo, in quanto i clienti più onerosi in termini di richiesta hanno una probabilità maggiore di risiedere in \emph{route} diverse.
I vicoli \ref{RR2} e \ref{RR3} durante l'esecuzione vengono rilassati ad ogni esplorazione dello spazio delle soluzioni, in modo da avere più clienti candidabili. In Table \ref{Table:1} viene rappresentata la selezione dei primi due centrodi, da parte dell'algoritmo.




\newpage


\begin{table}
		\begin{tabular}{c|c|c}
			\includegraphics[scale = 0.15]{images/RR1.png} & 
			\includegraphics[scale = 0.15]{images/RR2.png}  & 
			\includegraphics[scale = 0.15]{images/RR3.png}\\
			\\ \hline \\
			
			\includegraphics[scale = 0.15]{images/RR4.png} & \includegraphics[scale = 0.15]{images/RR5.png} & \includegraphics[scale = 0.15]{images/RR6.png}\\
			\\ \hline \\
			\includegraphics[scale = 0.15]{images/RR7.png} & \includegraphics[scale = 0.15]{images/RR8.png} & \includegraphics[scale = 0.15]{images/RR9.png}\\
						
		\end{tabular}
		\caption{In alto a sinistra il deposito al centro bianco e contorno nero, con tutti  clienti attorno da servire di colore grigio. In alto al centro l'algoritmo traccia il  raggio del utilizzando la distanza massima tra il deposito e il cliente più lontano, si definisce così il radar del deposito. Il raggio diminuisce in quanto i candidati che rispettano il vincolo \ref{RR3} si trovano più vicino al deposito,  i clienti che stazionano sulla frontiera diventano i possibili candidati, mentre gli esterni vengono esclusi,i clienti interni devono ancora essere esplorati . La figura centrale mostra il primo candidato sulla frontiera, selezionato come centroide con la distanza massima dal deposito, nella figura seguente, l'algoritmo traccia la distanza massima tra il centroide e tutti i clienti. Questa serve per tracciare il raggio del radar del centroide selezionato. Il raggio è scalato dividendolo per il numero di veicoli. Di conseguenza nella figura in basso a sinistra tutti i clienti all'interno del raggio del centroide sono esclusi dalla lista dei possibili candidati.Il raggio del radar del deposito diminuisce e dando la possibilità ad altri clienti di diventare condidati se e solo se rispettano \ref{RR3}. Viene quindi selezionato il nuovo centroide sulla frontiera e tracciato il raggio che comporrà il suo radar, come in figura in basso a destra.}
		\label{Table:1}
\end{table}

\begin{lstlisting}[language=Python, caption=RadarRadiusFrontier selettore di centroidi per Fisher and Jaikumar ,escapeinside={(*}{*)}]
def RadarRadiusFrontier(graph,n_vehicles):
	Dimension = graph.getDimension()
	Capacity = graph.getCapacity()
	Demands:list = graph.getDemands()
	scaleDown = 2
	depotDistance:list = [(*$c_{v,0} \  \forall v \in V$*)]
	seeds = []
	scannerRadius = DepotDistance
	maxCoverDistance = 0

	while (len(seeds)< n_vehicles):
		candidates = []
		if ( (*$ \sum_{i \in V} d_{i} \ \neq Dimension-1  $*)):
			for i in range(Dimension):
				if(demand[i] (*$\geq$*) capacity/scaleDown)
					candidates.append(i)
		else:
			candidates = np.arange(Dimension)
		
		for c in candidates:
			if(depotDistance[c] (*$\geq$*) argmax(scannerRadius)):
				if(seeds is empty):
					seeds.append(c)
					scannerRadius[c] = 0
					maxCoverDistance = graph.getArgMaxNodeDistance(c)
					break
			
				for v in seeds:
			 		if((graph.getValue(c,v) >= maxCoverDistance/n_vehicles) and (c not in v)): 
			 			seeds.append(c)
			 			scannerRadius[c] = 0
			 			if(maxCoverDistance < graph.getArgMaxNodeDistance(c)):
			 				maxCoverDistance = graph.getArgMaxNodeDistance(c)
			 			break
			 		else:
			 			scaleDown = scaleDown + 0.5
			 			scannerRadius[c]=0
			 			continue
			 		
		if ( (*$ \sum_{i \in V} d_{i} \ \neq Dimension-1 $*) and  No seeds added):
			print("Decrease Radius")
			scannerRadius[np.argmax(scannerRadius)] = 0
			
				
\end{lstlisting}
L'algoritmo descritto in Listing 3, presenta quanto già descritto formalmente sopra. Dalla riga 2 alla 4 si riportano le informazioni acquisite dal grafo, in 5 si inizializza il fattore di scala applicato ad ogni ciclo, che verrà aggiornato rilassando così il vincolo \ref{RR3}. In 6 si estraggono le distanze di ogni cliente dal deposito,in 7 si inizializza seeds, il contenitore di centroidi. In 8 si crea una copia di \textit{DepotDistance} andando così a creare \textit{ScannerRadius} che sarà utilizzato poi per ridurre il raggio del radar del deposito. 9 \textit{MaxCoverDistance} rappresenta la distanza massima tra centroidi e clienti.
Si inizia con la riga 11 dove il while termina solo quando avrà trovato un numero di centroidi uguale al numero di veicoli. In 13 si effettua un importante controllo: alcune istanze presenti nel dataset fornito in questo elaborato hanno una richiesta uguale per tutti i clienti spesso apri a 1. Di conseguenza se la richiesta è uguale per tutti i clienti, il vincolo sulla capacità può essere evitato, immettendo tutti i clienti come a riga 18. In caso contrario si aggiungono solo quelli che soddisfano il vincolo \ref{RR3} rilassato da scaleDown, righe 14,15,16. In 20 si scorrono tutta la lista di candidati, in 21 accetta solo i candidati con una distanza maggiore o uguale alla distanza massima tra i componenti di \textit{ScannerRadius}. Se troviamo un candidato che rispetta entrambi i controlli,in caso seeds sia vuoto possiamo aggiungerlo direttamente 22 - 26, azzeriamo il suo valore in \textit{ScannerRadius} e aggiorniamo \textit{MaxCoverDistance} con la distanza massima tra il candidato selezionato e il cliente più distante. Altrimenti scorriamo la lista di seeds, se il candidato è distante almeno \textit{MaxCoverDistance} diviso il numero di veicoli e il candidato non è già presente in seeds, lo aggiungiamo a seeds e aggiorniamo di conseguenza \textit{MaxCoverDistance}  righe 28 - -34.In caso contrario aumentiamo il fattore scaleDown e azzeriamo il candidato in \textit{ScannerRadius}. Le righe 40,41,42, vengono eseguire nel caso le richieste dei clienti siano diverse, rilassa il vincolo \ref{RR2} aumentando il bacino di candidati. 


\paragraph{Fase 2.2 e 2.3  General Assignement Problem} \hfill
Una volta individuati i centroidi si passa alla Fase 2.2. L'algoritmo deve assegnare ongni cliente ad ogni centroide. Per fare questo l'algoritmo risolve un problema di asseganemtno generale.Si richiede di trovare un assegnamento dei clienti ai cluster tale da non superare la capacità del veicolo assegnato al cluster. Il numero di chilometri totali percorsi dalla soluzione va minimizzato. Più formalmente:
\[x_{i,k} = \left\{
\begin{array}{lr}
1 :se i \ assegnato \ al \ cluster \ k \\
0 :altrimenti
\end{array}
\right.
\]

\begin{equation} \label{GAP1}
min \sum_{i \in V} \sum_{k \in K} x_{i,k} \cdot a_{i,k} 
\end{equation}

\begin{equation} \label{GAP2}
 \sum_{k \in K} x_{i,k} = 1 \ \forall i
\end{equation}

\begin{equation} \label{GAP3}
\sum_{i \in V} d_{i}  \cdot x_{i,k} \leq C \ \forall k
\end{equation}

\begin{equation} \label{GAP4}
x_{i,k} \in \{0,1\}
\end{equation}


\begin{table}
	\begin{tabular}{c|c|c}
		\includegraphics[scale = 0.13]{images/CL-FJ-a} & 
		\includegraphics[scale = 0.13]{images/FJ_CL.png}  & 
		\includegraphics[scale = 0.13]{images/FJ_R.png}\\	
	\end{tabular}
	\caption{Un esempio di risoluzione GAP una volta scelto i centroidi. A sinistra vengono calcolati i costi di inserimento per ogni vertice in ogni cluster. In centro avviene l'assegnamento, associando ogni nodo al cluster che ha un costo di inserimento minore. A destra si prosegue con il routing di ogni cluster: in questo caso si usa l'algoritmo Nearest Neighbor partendo dal deposito e proseguendo verso il nodo più vicino appartenente al cluster, si prosegue per vicinanza collegando il resto dei nodi in ogni singolo cluster.}
	\label{Table:2}
\end{table}

\pagebreak

\begin{lstlisting}[language=Python, caption=General Assignement Problem solver ,escapeinside={(*}{*)}]
def GAPsolver(graph,Kclusters):
	Dimension = graph.getDimension()
	Capacity = graph.getCapacity()
	Demands:list = graph.getDemands()
	Nclusters = len(Kclusters)
	allocCosts:[list,list] = [(*$ allocCosts_{i,k} = 0 \ \forall i \in V \wedge k \in Nclusters $*)]
	clusterAssignement:list = []
	clusterDemand:list =  [(*$ clusterDemand_{k} = 0 \ k \in Kclusters $*)]
	
	allocCosts:list = [(*$ allocCosts_{i,k} =calculateIns(i,k) \ \forall i \in V \wedge k \in Nclusters $*)]
	
	i=1
	for alloc in allocCosts:
		for k in Kclusters:
			if(clusterDemand[argmin(alloc)] + Demands[i] <= Capacity):
				clusterDemand[argmin(alloc)] =+ Demands[i]
				clusterAssignment.append(np.argmin(alloc))
				i++
				break
			else:
				alloc[argmin(alloc)] = np.inf
				print("Cluster Overloaded")

	if(len(clusterAssignment)<Dimension-1):
		print("Solution is Invalid")
		return -1
	else:
		return clusterAssignment
															
\end{lstlisting}

Listing 4 presenta lo pseudocodice implementato del GAP solver implementato. Alla riga 1 la firma del metodo riceve il graph e i centroidi selezionati con le tecniche descritte nella sezione precedente.Dalla riga 2 alla riga 4 si recuperano le informazioni sul grafo, in 5 si estrae il numero di cluster. \textit{allocCosts} è la lista che conterrà i costi di allocazione di ogni cliente per ogni cluster, alla riga 5 viene inizializzata a 0 e ha dimensione uguale a \textit{Dimension}* \textit{Ncluster}. In 7 viene inizializzata a vuoto la lista \textit{clusterAssignement} che conterrà i nodi assegnati ad ogni cluster. In 8 si inizializzano a 0,il totale di domande soddisfatte per ogni cluster. In 10 vengono calcolati i costi di inserimento di ogni nodo per ogni cluster: \textit{calculateIns(i,k)} calcola i costi come è stato già descritto nella sezione \textbf{\ref{FJ-Sec}}. In 12 si inizializza il puntatore \emph{i} che servirà per puntare alla domanda del nodo corrispondente in \textit{Demands}. 13 e 14 si occupano di scorrere ogni riga di \textit{allocCosts} e al suo interno ogni cluster di \textit{Kcluster}. Il controllo a riga 15, assicura che il cluster con costo di inserimento minimo per il nodo, non superi la capacità prestabilita. Se il controllo viene superato con successo alla riga 16 si aggiorna la domanda totale soddisfatta dal cluster, in 17 si assegan al nodo il cluster e in 18 si incrementa di uno il puntatore. Siccome il nodo è stato assegnato con 19 si passa alla prossima riga di \textit{allocCosts}. Altrimenti, se il controllo a riga 15 fallisce, la riga 21 pone ad infinito il valore minimo calcolato per quel nodo, in modo che nel ciclo seguente si prenda in considerazione il secondo valore minimo calcolato tra quel nodo e un altro cluster, questo viene ripetuto per k in Kclusters.
Se alla fine dei due cicli, la lunghezza della lista \textit{clusterAssignement} non è pari al numero di nodi escluso il deposito, vuol dire che l'allocazione clienti-clusters non è andata a buon fine. Quindi la soluzione è invalida, sarà necessario aumentare il numero di veicoli e quindi si ritorna -1 . Altrimenti se tutto va bene, si ritorna l'assegnamento attraverso la lista \textit{clusterAssignement}. 

\paragraph{Fase 2 - Routing } \hfill

Ora che gli assegnamenti sono stati decisi, ci dobbiamo preoccupare di collegare i nodi all'interno di ogni cluster, in modo da formare le \emph{routes} necessarie per descrivere la soluzione. La descrizione formale di questo problema è simile a quella già descritta nella sezione  \ref{RappProb-sec}: La funzione obiettivo che descrive questa fase è la seguente:
\begin{equation} \label{objF2}
\min \sum_{k \in K} \sum_{(i,j) \in A} c_{i,j} \cdot M_{i,j}^k 
\end{equation}

\begin{equation} \label{}
M_{i,j}^k \in \{0,1\}
\end{equation}

A differenza di ciò che è descritto nella sezione  \ref{RappProb-sec} i vincoli sono già stati rispettati dalla lista di assegnamento fornita dal GAP solver.



In questa elaborato sono state utilizzate due tecniche per implementare il routing:
\begin{itemize}
\item \textbf{Nearest Neighbourn}: Partendo dal deposito ci si collega al nodo successivo più vicino, si prosegue fino a quando tutti i nodi sono stati collegati.

\begin{lstlisting}[language=Python, caption=NearestNeighbourn Routing ,escapeinside={(*}{*)}]
def Routing_NearestNeighbourn(graph,clusterAssignement,Kclusters):
	Demands = graph.getDemands()
	Capacity = graph.getCapacity()
	routes:list = []
	
	for k in Kclusters:
		cluster:list =  []
		for i in range(len(clusterAssignment)):
			if(clusterAssignment[i] == k ):
				cluster.append(i+1)
				
		appoRoute =  Route(Capacity) 
		appoRoute.addCustomer(deposit)
			
	    while(len(cluster)>0):
				prevnode = appoRoute.getLastCustmerServed()
				distPrevNode = [(*$c_{prevnode,i}  \forall i \in cluster $*)]
				nearestN = cluster[np.argmin(distPrevNode)] 
				if nearestN not in appoRoute.getCustomers():
					appoRoute.addCustomer(nearestN)
					cluster.remove(nearestN)
			
		appoRoute.addCustomer(deposit)
		routes.append(appoRoute)
			
	return routes

\end{lstlisting}
Listing 5 presenta lo pseudocodice: la firma del metodo in linea 1 richiede il grafo, l'assegnamento creato dal GAP solver, i \textit{Kcluster} selezionati dalla procedura precedente. La riga 2,3 estraggono le informazioni dal grafo, la 4 inizializza la soluzione da ritornare \textit{routes} a vuoto. Da 6 a 10 si creano i singoli cluster, scorrendo la lista \textit{clusterAssignement} e individuando a quale cluster sono stati assegnati i clienti. Per ogni cluster è creata una lista \textit{cluster}. Dentro al ciclo che scorre i cluster in 6, si inizializza la \emph{appoRoute},con capacità e deposito 12,13. Questa \emph{route} collegherà i clienti della lista  \textit{cluster} che abbiamo appena popolato. All'interno del while a riga 15, si estrae l'ultimo nodo inserito in \emph{appoRoute} e si calcolano tutte le distanze dei clienti che popolano la lista \textit{cluster} 16, 17. Si trova il più vicino al nodo estratto \textit{prevNode} 18. Se il nodo non è ancora presente nella  lista di clienti di \emph{appoRoute}, lo aggiungo e lo rimuvo dalla lista \textit{cluster} 20,21. Una volta raggiunti tutti i clienti chiudo la strada aggiungendo il deposito alal fine della lista di clienti,e aggiungo \textit{appoRoute} a \textit{routes}. Dopo aver esaurito i componenti di \textit{Kcluster}, ritorno la soluzione \textit{routes}.
\item \textbf{Nearest Neighbourn TrackPath}: Partendo dal deposito si crea una \emph{route} per ogni cliente appartenente al cluster, si espandono quindi i percorsi che hanno un costo minore. I percorsi vengono espansi aggiungendo il nodo più vicino. Infine si ritorna la \emph{route} meno costosa per ogni cluster.

\begin{lstlisting}[language=Python, caption=Nearest Neighbourn TrackPath Routing ,escapeinside={(*}{*)}]
def Routing_NN_TrackPath(graph,clusterAssignement,Kclusters):
	Demands = graph.getDemands()
	priorityQ:list =[]
	finalRoutes:list = []
	
	for k in range(len(Kclusters)):
		cluster = []
		routes =[]
		for i in range(len(clusterAssignment)):
			if(clusterAssignment[i] == k ):
			cluster.append(i+1)
	
		for node in cluster:          
			nodeRoute = Route(graph.getCapacity())
			nodeRoute.addCustomer(0)
			nodeRoute.addCustomer(node)
			nodeRoute.setCost(graph.getValue(0,node))
			priorityQ.append(nodeRoute)
		
		priorityQ.sort(key=lambda x: x.getCost(),reverse=True)
	
		while (len(priorityQ) > 0) :
			shortRoute = priorityQ.pop()
			
			prevNode = shortRoute.getLastCustmerServed()
			appoCluster:list = []
			for v in cluster:
				if v!= prevNode:
					if(v is not in shortRoute):
						appoCluster.append(v)
					
			if (len(appoCluster) > 0):
				index,value = graph.getNearestNeighbours(prevNode,appoCluster)
				costToAdd = shortRoute.getCost() + value
				shortRoute.setCost(costToAdd)
				shortRoute.addCustomer(appoCluster[index],demand[appoCluster[index]],False)
				priorityQ.append(shortRoute)
				priorityQ.sort(key=lambda x: x.getCost(),reverse=True)
				
			else:
				value = graph.getValue(prevNode,0)
				costToAdd = shortRoute.getCost() + value
				shortRoute.setCost(costToAdd)
				shortRoute.addCustomer(0,0,False)               
				routes.append(shortRoute)
			
			routes.sort(key=lambda x: x.getCost(),reverse=True)
			route = routes.pop()
			finalRoutes.append(route)
	
	return finalRoutes
\end{lstlisting}
In Listing 6 la firma del metodo è uguale a Listing 5. La  riga 2 estrae la \textit{Demand} dal grafo.
3 inizializza la priority queue \textit{priorityQ} che conterrà le strade da esplorare, ordinate in base al costo. In riga 4 si inizializza \textit{finalRoutes},la lista di \emph{routes} che sarà ritornata come soluzione. Le righe da 6 a 11 inizializzano il contenitore \textit{cluster} come già abbiamo visto nella procedura precedente. In 8 si inizializza \textit{routes} una variabile di appoggio per rendere disponibile le \emph{route} esplorate anche al di fuori del ciclo. Da 13 a 18 per ogni cliente nel cluster viene creata una \emph{route} deposito $\rightarrow$ cliente, con relativo costo, e aggiunta alla lista \textit{priorityQ}.
Al di fuori del ciclo alla riga 20 la lista viene ordinata in ordine decrescente. Si prosegue con la riga 22 dove il ciclo while controlla lo stasto della coda \textit{priorityQ}. In 23 si estrae il primo nodo della coda, che equivale alla strada più breve trovata fino a questo punto. Alla riga 22 si estrae l'ultimo nodo servito da \textit{shortRoute}. Da 26 a 30 si utilizza la lista \textit{appoCluster} per collezionare i nodi non ancora collegati a \textit{shortRoute}. In 31 si controlla la lunghezza di  \textit{shortRoute}, se contiene elementi allora si cerca il cliente più vicino a \textit{prevNode} all'interno della lista \textit{appoCluster} in riga 33. Una volta trovato il cliente, lo si aggiunge a \textit{shortRoute}, aggiornando il costo e la domanda: da riga 34 a 36. Si aggiunge la nuova \emph{route} a \textit{priorityQ}, e si ordina in ordine decrescente in 37 e 38.
Quando la lista \textit{appoCluster} non contiene più elementi si chiude la \emph{route}, aggiungendo come destinazione finale il deposito e aggiornando opportunamente i costi e la domanda: da riga 41 a 44.Infine la strada viene aggiunta a \textit{routes} 45. Quando tutte le strade sono state esploarate e collegate a tutti i nodi del cluster si sceglie la meno costosa, ordinando \textit{routes} in ordine decrescente in 47. Si  estrae la \emph{route} meno costosa in 48, e si aggiunge alla soluzione finale \textit{finalRoutes} in 49. Questa procedura viene svolta per ogni \textit{Kcluster}. Infine si ritorna la soluzione  \textit{finalRoutes}


\end{itemize}


\subsubsection{Metodo Euristico Route First, Cluster Second}
Una procedura inversa rispetto a quella che abbiamo presentato: nella prima fase si tende a costruire una grande unica \emph{route} rilassando il vicolo sulla capacità dei veicoli. Nella fase successiva si reintroduce il vincolo dividendo la singola grande \emph{route} costruita in \emph{route}  più piccole, portando il veicolo al deposito, tali da rispettare il vincolo sulla capacità. Ci sono ovviamente più modi per creare trovare una soluzione con questo metodo: si può scorrere i nodi della singola \emph{route} in ordine e ogni qualvolta la capacità eccede si chiude il tracciato e si inizia dal nodo successivo con una nuova  \emph{route}; oppure si costruisce un grafo ausiliario nel seguente modo: i nodi sono i clienti, gli archi entranti sono composti dal numero massimo di clienti che un veicolo può visitare senza superare la sua capacità compreso il nodo di partenza e di arrivo, il peso degli archi rappresenta i chilometri percorsi dal nodo di partenza al nodo di arrivo.
La rappresentazione attraverso grafo ausiliario e la conseguente applicazione dell'algoritmo di Dijkastra è l'implementazione  scelta in questo elaborato per quanto riguarda il metodo di raggruppamento route first, cluster second. In Table \ref{Table:3} un esempio esplicativo.
\begin{table}
	\begin{tabular}{c|c}
		\includegraphics[scale = 0.20]{images/RFSC1.png} & 
		\includegraphics[scale = 0.20]{images/RFSC2.png}  
	
	\end{tabular}
	\begin{centering}
		\includegraphics[scale = 0.20]{images/RFSC3.png}\\	
	\end{centering}

	\caption{Il grafo viene rappresentato escludendo il deposito,i clienti sono distirbuiti in ordine \textbf{topologico}, di conseguenza una volta arrivati al'ultimo nodo sarà sufficente procedere dall'ultimo nodo fino al primo per ricostruire la soluzione. In sostanza ogni arco del grafo rappresenta una \emph{route} l'algoritmo di Dijkastra esplora gli archi che portano al nodo finale minimizzando il costo totale del percorso,in questo caso i kilometri percorsi per ogni \emph{route}. }
	\label{Table:3}
\end{table}

\begin{lstlisting}[language=Python, caption=Route First Cluster Second con grafo ausiliario e Dijkastra  ,escapeinside={(*}{*)}]
def ClusterFirst_RouteSecond(graph):
	Capacity = graph.getCapacity()
	Demands = graph.getDemands()
	Dimension = graph.getDimension()
	dist:list = [(*$ dist_v =  \infty \ \forall v \in V $*)]
	nodeQueue:list= []
	finalRoutes:list = []
	auxGraph = [(*$auxGraph_v =(i,Route(Capacity))  \ \forall v \in V$*) ]
	
	dist[0] = 0	
	route = Route(capacity)
	route.addCustomer(0,demand[0],False)
	route.addCustomer(1,demand[1],False)
	route.addCustomer(0,demand[0],False)
 	route.setCost(graph.getValue(0,1) + graph.getValue(1,0))
	
	nodeQueue = [(1,route.getCost(),route)]
	node = 0
	nodeQueue.sort(key=lambda x: x[1],reverse=True)
	
	while (len(nodeQueue)>0):
		nodeToexpand = nodeQueue.pop()
		node = nodeToexpand[0]
		cost = nodeToexpand[1]
	
		for j in range(1,dimension):
			if(j >= node):
				newRoute = Route(capacity)
				newRoute.setCost(0)
				newRoute.addCustomer(0,demand[0],False)
				for i in range(node,j+1):
					if (i is not in newRoute and do not overload newRoute):
						newRoute.addCustomer(i)
						newRoute.setCost(newRoute.getCost()+ newRoute.getCost(lastNode,i))
					else:                            
						break
						
					newRoute.setCost(newRoute.getCost() + graph.getValue(j,0))
					newRoute.addCustomer(0)
					if(dist[j] > newRoute.getCost()+ cost):
						dist[j] = newRoute.getCost() +cost
						nodeQueue.append((j+1,dist[j],newRoute))
						auxGraph[j] = (node-1,newRoute)
						nodeQueue.sort(key=lambda x: x[1],reverse=True)
					else: break	
	
	u = len(auxGraph)-1
	while (u != 0):
		node = auxGraph[u]
		u = node[0]
		finalRoutes.append(node[1])
	
	return finalRoutes				
		
\end{lstlisting}
Listing 7 mostra alla riga 1 al firma del metodo, la quale richiede come input solo il grafo. In questo metodo non è possibile scegliere a priori il nuemro di veicoli, in quanto dipende da come viene gestito l'algoritmo di routing. Dalla riga 2 alla riga 4 si estraggono le informazioni dal grafo come abbiamo già visto precedentemente.Ala riga 5 si inizializza la lista di \textit{dist}, ovvero la lista che contiene i nodi e per ogni nodo assegna il corrispettivo numero totale di chilometri per raggiungere il nodo. In riga 6 si inizializza \textit{nodeQueue} la coda che contiene per ogni elemento, il nodo, la distanza percorsa per raggiungerlo e la \emph{route} utilizzata per raggiungere il nodo. In 7 si inizializza \textit{finalRoutes} la lista di \emph{route} che conterrà la nostra soluzione. A riga 8 viene inizializzato il grafo ausiliario \textit{auxGraph} che contiene per ogni elemento: il nodo e la strada utilizzata per raggiungerlo.
A riga 10 \texttt{dist[0]} viene assegnato a  \emph{0}, questo valore non verrà mai utlizzato durante tutta l'esecuzione dell'algoritmo, serve solamente per mantenere una coerenza con gli indici dei vertici \emph{V}. Di conseguenza dalla riga 11 alla 15 di crea la strada corrispondente al nodo sorgente, con costo uguale a 0. In 17 si inizializza \textit{nodeQueue} con il nodo sorgente, la distanza pari a alla lunghezza di  \emph{route}  e la \emph{route} corrispondente.
In 18 si inizializza la variabile \textit{node} in 19 si ordina in ordine decrescente \textit{nodeQueue}. Alla riga 21 il \texttt{while} si occupa di scorre tutta la lista \textit{nodeQueue}, fino al suo esaurimento. In 22 si estrae il nodo dalla coda \textit{nodeQueue} con costo minore, in 23 viene inserito l'indice identificativo del nodo , mentre in 24 viene riposto il suo costo. Il \texttt{for} a riga 26 crea tutti i figli del nodo, rispettando l'ordine topologico garantito dal controllo a riga 27. Per ogni figlio si crea una \emph{route} che parte dal deposito, inizializzando il costo a \emph{0}, righe da 28 a 30. Alla riga 31 il ciclo \texttt{for} scorre tutti i nodi tra il nodo estratto  \textit{node} e il figlio \emph{j+1}, 32 controlla se \emph{i} non è presente nella \textit{newRoute} e non supera il vincolo di capacità, le righe 33 e 34 lo aggiungono aggiornando il costo di \textit{newRoute} di conseguenza.
Altrimenti in si esce dal ciclo con 36, in 38 e 39 si chiude la strada. In 40 si verifica l'aggiornamento del costo dei figli esplorati confrontando il costo per arrivare la nodo figlio \textit{j} con il costo di \textit{newRoute} sommato al costo del percorso già effettuato per arrivare al nodo padre \textit{cost}. Se \textit{dist[j]} risulta maggiore, si aggiorna con il nuovo costo in 41. In 42 si aggiorna \textit{nodeQueue} con \textit{j+1} il nodo dove l'arco entra, costo dell'arco nella lista \textit{dist[j]} per arrivare al nodo  e \textit{newRoute} il collegamento tra \textit{node} e \textit{j+1}. Una volta terminato di esplorare tutti gli elementi presenti nella coda \textit{nodeQueue}, si procede estreendo l'ultimo elemento del grafo in ordine topologico e fino a quando non si arriva al nodo sorgente si risale il grafo ausiliario, percorrendo e salvando gli archi in \textit{finalRoutes}, componendo così la soluzione finale. In 53 si ritorna \textit{finalRoutes}.

\subsection{Metodi metaeuristici}
Le caratteristiche principali degli algoritmi metaeuristici sono l’esplora-
zione approfondita delle regioni, considerate più promettenti, dello spa-
zio delle soluzioni e l’impiego di sofisticate regole di ricerca del neighbo-
rhood, particolari strutture dati e metodi di ricombinazione delle solu-
zioni. Una caratteristica che spesso distingue questi algoritmi da quelli
euristici è che il procedimento di ricerca può passare attraverso soluzioni
non ammissibili e/o fasi non migliorative.
Il tempo necessario a questi algoritmi per giungere ad una soluzione
ottima è sensibilmente maggiore rispetto alle performance degli euristi-
ci classici, ma i risultati ottenuti sono solitamente di qualità superiore.
Inoltre, l’esecuzione di questi algoritmi è subordinata alla corretta valu-
tazione e impostazione di un predeterminato numero di parametri, pro-
pri dell’algoritmo stesso, al fine di adattare il metodo di risoluzione al
problema e ottenere la soluzione migliore possibile.

\subsubsection{Algoritmo Genetico}
Nel 1975 è stato proposto, da Holland, il paradigma alla base degli ago-
ritmi genetici: si tratta di una tecnica che cerca di risolvere problemi
imitando i processi tipici dell’evoluzione naturale. In via del tutto gene-
rale, l’idea di fondo consiste nel mantenere memoria di stringhe di bit,
chiamate cromosomi, rappresentanti la codifica binaria di una soluzione
al problema. L’evoluzione della popolazione è ottenuta applicando degli
operatori che simulino i più importanti fenomeni naturali: riproduzione
e mutazione.Una descrizione generica del paradigma può essere data nelle seguenti
modalità: innanzitutto sia definita una popolazione iniziale di cromosomi:
\begin{equation}
 X^1 = \{ x_{1}^1,..,x_{N}^1\}
\end{equation}
alla quale  ad ogni iterazione \emph{t = 1,..,T} sono applicate \emph{k} volte con \emph{k=N/2} le operazioni di riproduzione,ricombinazione e mutazione seguite dal passo finale di rinnovo generazionale.

\begin{itemize}
\item \textbf{Riproduzione}: Si selezionano, dalla popolazione \emph{$X^t$} , due cromosomi
generatori, privilegiando statisticamente la scelta dei cromosomi
migliori;
\item \textbf{Elitarismo (Elitism)}:Il cromosoma migliore viene sempre preservato e reintrodotto nelle generazioni future.

\item \textbf{Ricombinazione (Crossover)}: Si applica un operatore di crossover ai due gene-
ratori in modo da ottenere una nuova coppia di cromosomi discen-
denti ;

\item  \textbf{Mutazione}: Con una bassa probabilità, si applica l’operatore di mutazione ai cromosomi discendenti;
\item  \textbf{Rinnovo generazionale}: A partire da \emph{$X^t$} , si crea la popolazione \emph{$X^t+1$} rimuovendo le 2k peggiori soluzioni e sostituendole con le 2k generate nelle k precedenti applicazioni dei passi elencati.
\end{itemize}
Al termine delle \emph{T} iterazioni, si prende come soluzione finale la mi-
gliore dell’ultima generazione.
Ciò che contraddistingue questo paradigma è l’assoluta generalità della sua specifica. Così come è stato descritto, infatti, esso può essere
applicato a diverse tipologie di problema. Il punto chiave riguarda, in
realtà, la definizione degli operatori di crossover e mutazione, che necessariamente si differenzieranno a seconda del problema affrontato. Inoltre,
bisogna definire come una soluzione ad un determinato problema deve
essere codificata in una stringa di bit, imponendo quindi una serie di
regole per l’ammissibilità delle stringhe/soluzioni.
Nel caso specifico, per i problemi di VRP, la codifica in stringhe di
bit dei route che compongono una soluzione non è la traduzione più
adatta. Si preferisce codificare i route con delle sequenze di interi, dove
la posizione dell’intero nella stringa indica l’ordine di visita, nel route,
del vertice corrispondente. L’intero 0, rappresentante il deposito, può
comparire più volte nella stringa ed è spesso utilizzato come carattere
separatore tra i route.



\begin{lstlisting}[language=Python, caption=Algoritmo Genetico ,escapeinside={(*}{*)}]
def GeneticAlgorithm(graph):
	DemandsTot = graph.getTotalDemand() 
	Capacity = graph.getCapacity()
	mutationRate = 1
	Npopulation = 100
	population:list = []
	Eras = 40
	era = 0
	
	n_vehicles = int( math.ceil(DemandsTot/Capacity))           
	
	for i in range(n_population):
		K_clusterRand = [(*$random(1,Dimension-1) ] \ \forall v \in Nvehicles $*)]
		GAPassignementRand = GAPsolver(graphToSolve,K_clusterRand)
		if(GAPassignementRand != -1):
			chromosome = NearestNeighbourn(graphToSolve,GAPassignementRand,K_clusterRand) 
			if(SearchaAndCompleteSequence(chromosome,graphToSolve)):
				print("Invalid! ")
			else:
				population.append((sum([c.getCost() for c in chromosome]),chromosome))
			
	while(era<Eras):
		toKeep = Elitism(Population)
		popEra:list = []
		
		for k in range(len(population)/2):
		
			winner1,winner2 ,f1,f2= Tournament(population)   
			children,fittingCrossover = Crossover(winner1,winner2,graphToSolve)
			if (fittingCrossover>f1 or fittingCrossover>f2):
				continue			
			if(SearchaAndCompleteSequence(children,graphToSolve)):
				print("Invalid! " +str(fittingCrossover))
			else:
				popEra.append((fittingCrossover,children))
				popEra.sort(key=lambda x:x[0],reverse=True)	
						
			if (np.random.randint(1,100) <= mutationRate):
			    if(len(popEra)>0):
			    	mutantChild = popEra[0]
			    else: break 
				for route in mutantChild[1]:
					c1 = randomCustomer(route.getCustomers())
					c2 = randomCustomer(route.getCustomers())
					route = FlippingPath(route,graphToSolve,c1,c2)					
				fittingMutation = MutantChild[1].routeCost()
				if(fittingMutation < mutantChild[0]):
					if(SearchaAndCompleteSequence(children,graphToSolve)):
						print("Invalid! " +str(fittingCrossover))
					else
						popEra.append((fittingMutation,mutantChild[1]))
						print("CROSSOVER + MUTATION FLIPPING  ==> "+str(fittingMutation))
										
				popEra.sort(key=lambda x:x[0],reverse=True)
				best = [popEra.pop() for i in range(int(len(popEra)/2))]			
				population.substituteBestChildren(best)
			
			if toKeep not in population:
				population.append(toKeep)
				era = era + 1
			
		population.sort(key= lambda x: x[0], reverse = True)
		bestGeneticSolution = population.pop()[1]    
	
	return 	bestGeneticSolution
\end{lstlisting}

\begin{enumerate}
\item \textbf{Riproduzione}: Si utilizza il metodo di selezione dei centroidi casuale congiunto all'algoritmo di routing Nearest Neoghbourn, già presentato nella sezione precedente.
Alla riga 2 e 3 si estraggono le informazioni necessari dal grafo. Alla riga 4 e 5 si settano i parametri \textit{mutationRate} e \textit{Npopulation} che definiscono rispettivamente, la probabilità che un cromosoma subisca una mutazione e la grandezza della popolazione di cromosomi. Alla riga 6 si inizializza la lista che conterrà la popolazione di cromosomi. In 7 e8 si inizializza il numero di ere a cui ogni popolazione sarà sottomessa. Il numero di veicoli è stimato con un lower bound: la domanda totale diviso la capacità di un singolo veicolo, riga 10. Alla riga 12 il ciclo \texttt{for} scandisce il numero della popolazione, al suo interno alla riga 13 e 14, si scelgono casualmente i centroidi e si risolve il \textit{GAP} corrispondente. Se l'assegnamento risolto è valido, si procede con il \emph{routing} da parte dell'algorimo \texttt{Nearest Neightbourn}, altrimenti si passa alla creazione del prossimo cromosoma, riga 15 a 20.
Successivamente si eseguono le operazioni di \textit{Ricombinazione} e \textit{Riproduzione} un numero di volte uguale a \textit{Eras} riga 22.

\item  \textbf{Elitarismo}:
Per ogni era si salva il cromosoma migliore all'interno della popolazione. Questo viene reintrodotto nelle generazioni future, oppure riutilizzato durante i crossover e le mutazioni.Alla riga 24 si inizializza \textit{popEra} che conterrà gli elementi geneticamente modificati di  \textit{population}.

\item \textbf{Ricombinazione (Crossover)}
Alla riga 26 scandisce il numero di volte che la popolazione subirà un editing genetico, in questa implementazione \emph{h=N/2}. La riga successiva 28 estrae i due candidati, per fare ciò chiama il metodo \texttt{Tournament} che data come input la popolazione, ritorna due candidati, in questo metodo di default ritorna due candidati random, ma è possibile specificare se si vuole il migliore e il peggiore della popolazione. Alla riga 29, si applica la ricombinazione attraverso l'istruzione \texttt{Crossover} che prende in input i due candidati e il grafo.
La ricombinazione funziona in questo modo: copia una parte di soluzione estratta dal primo candidato all'interno del nuovo cromosoma e definisce il resto della soluzione seguendo l'ordine di visita del secondo candidato, ovviamente senza inserire doppioni. Più precisamente, i cromosomi rappresentano le soluzioni come lunghe sequenze di clienti intervallate dal deposito \emph{0} le sequenze hanno la stessa lunghezza essendo soluzioni dello stesso grafo. Si individuano due punti dove tagliare le soluzioni, la parte di soluzione  appartenente al primo candidato compresa tra questi due punti sarà copiata all'interno del nuovo cromosoma, disponendola nella stessa posizione da cui è stata copiata. Le posizioni rimanenti sono riempite una alla volta , partendo dal secondo punto di taglio fino alla fine del secondo candidato e successivamente partendo dall'inizio fino al primo punto di taglio sempre del secondo candidato, fino al completamento della soluzione.
Questo tipo di ricombinazione prende il nome di \textbf{Order Crossover} \cite{OCR}.
Con un esempio, prendiamo 2 padri \emph{$p_1$} e \emph{$p_2$}:

\begin{center}
 \emph{$p_1 = (1 2 3 \mid 5 4 6 7 \mid 8 9 )$}
\end{center}

\begin{center}
	\emph{$p_1 = (4 5 2 \mid 1 8 7 6 \mid 9 3 )$}
\end{center}
Il primo figlio è \emph{$c_1$}  
\begin{center}
	\emph{$c_1 = (2 1 8 \mid 5 4 6 7 \mid 9 3)$}
\end{center}

Se scambiamo i ruoli di \emph{$p_1$} e \emph{$p_2$} otteniamo il  secondo figlio \emph{$c_2$}  
\begin{center}
	\emph{$c_2 = (3 5 4 \mid 1 8 7 6 \mid 9 2)$}
\end{center}

Solo il cromosoma figlio con il minor numero di chilometri trascorsi viene aggiunto a \textit{popEra} 


Tornando al nostro pseudocodice, alla linea 30 si controlla se la soluzione ritornata da \texttt{Crossover} è migliore di almeno uno dei due candidati, in caso contrario si va direttamente alla prossima era 31, in caso contrario si controlla se la soluzione è valida  con il metodo \texttt{earchAndComleteSequence} a riga 32. Se la soluzione è valida viene aggiunta alla \textit{popEra} e la lista di conseguenza riordinata.

\item \textbf{Mutazione}
Il controllo a riga 38, estrae un numero a random e se questo è minore alla percentuale segnalata da \textit{mutationRate}, la soluzione peggiore all'interno della popolazione, controllando che popEra non sia vuota: righe 39 a 41. Il ciclo a riga 42 scorre tutte le \emph{route} della soluzione , al suo interno vengono scelti due clienti random, quindi viene chiamato il metodo \texttt{FlippingPath}: 43,44,45.
Il metodo dato in input, \emph{route} , il grafo e i due clienti, li scambia di posto all'interno della stessa \emph{route} riconnettendo i clienti con i rispettivi nuovi vicini. Da 47 a 52 si effettuano i controlli necessari per assicurarsi che la nuova soluzione sia valida e che questa sia migliore rispetto alla soluzione di partenza.

\item \textbf{Rinnovo Generazionale}
In 54 \textit{popEra} viene riordinato , in \textit{best} vengono riposte solo metà dei migliori cromosomi. In 55 si sostituiscono i cromosomi migliori all'interno di \textit{population}, da 58 e 60 si reintroduce la soluzione memorizzata con elitismo nel caso sia andata persa. 62 e 63 estraggono la miglire soluzione e in 64 viene ritornata.

\end{enumerate}

\section{Analisi di Complessità}
Segue l'analisi di complessità degli algoritmi presentati.
\subsection{Clarke and Wright Sequenziale}: 
Il calcolo della lista \textit{savings} in riga 4 richiede tempo pari a \emph{$O(V^2)$}. A questo punto la lista viene \textit{savings} ordinata e richiede una complessità pari a \emph{$O(n^2)$} dove \emph{n} sono gli elementi appartenenti alla lista, tutti i vertici a parte il deposito. Nel \texttt{while} ricerca sel la soluzione è completa: scorre gli elementi presenti in ogni \emph{route} contandoli e ritorna \texttt{false} se la soluzione non è completa, scorrendo così nel caso peggiore  \emph{$O(V)$}. Alla riga 14 il while scorre la lista  \textit{savings}, e ogni un nodo viene aggiunto alla \emph{route} si toglie un elemento e si ricomincia dall'inizio della lista \textit{savings}, con una complessità pari a  \emph{$O(\frac{n!}{\mid R \mid })$} dove \emph{R} è il numero di \emph{route} che compongono la soluzione. I controlli a riga 19 e 24 richiedono \emph{$O(c)$} con c appartenente ai clienti della \emph(route). La complessità finale è  \emph{$ O(V^2 + \frac{n!}{\mid R \mid })$}.

\subsection{Clarke and Wright Parallelo}:
Anche qui il calcolo della lista \textit{savings} in riga 4 richiede tempo pari a \emph{$O(V^2)$} e la lista  ordinata richiede una complessità pari a \emph{$O(n^2)$} dove \emph{n} sono gli elementi appartenenti alla lista, tutti i vertici a parte il deposito. Alla riga 7 si crea una \emph{route} per ogni cliente, questo richiede \emph{$O(V)$}. Il ciclo \texttt{for} a riga 9 scorre la lista \textit{savings} e in questa versione la lista viene scorsa tutta una sola volta, quindi con complessità \emph{$O(n)$}. Alla riga 14 si scorrono tutte le \emph{route} trovate e si cerca quale serve \emph{i} e quale serve \emph{j}. L'algoritmo inizia ci sono \emph{$\mid V \mid$} \emph{route}, nel caso peggiore una strada contiene tutti i clienti, la complessità da riga 14 a riga 19 è \emph{$O(V^2)$}. Se i due clienti \emph{i} e \emph{j} sono in due strade diverse e queste possono essere sottomesse al metodo \texttt{Merge}, vuol dire che \textit{RouteA} e \textit{RouteB} contengono \emph{l} nodi con \emph{$l < V$}. Il metodo unisce le due \emph{route} rispettando l'ordine di visita dei rispettivi clienti, quindi unisce le \emph{route} aggiungendo in coda o in testa i clienti in \textit{RouteA} o \textit{RouteB}, questo richiede complessità \emph{$O(l)$}. La rimozione a riga 24 richiede tempo costante \emph{O(1)}. La complessità totale dell'algoritmo parallelo è quindi \emph{$O(V^2)$}.	

\subsection{Fisher and Jaikumar}

\subsubsection{Selezioni dei centroidi}

\begin{itemize}
\item \textbf{Metodo Random}: Si estraggono a random \emph{k} clienti, complessità totale \emph{O(k)}

\item  \textbf{Radius Radar Frontier}: 
Alla riga 6si inizializza \textit{depotDistance} con tutte le distanze a \emph{0} per ogni vertice, richiede complessità \emph{O(V)}. Il \texttt{while} a riga 11, continua ad eseguire il suo nucleo fino a quando il numero di centroidi scelti è uguale al numero di veicoli richiesti, un buon lower bound di veicoli richiesti è \emph{$TotDem = (\sum_{d \in Demands} d)  \ / Capacity$}, questo perchè atrimenti la soluzione è invalida. Quindi complessità compresa tra \emph{$O(TotDem) \leq O \leq O(V)$}. Il controllo in 13 somma le domande di ogni clienti per capire se sono diverse tra loro, richiede complessità \emph{O(V)}, anche la riga 16 e la riga 18. In riga 20 il \texttt{for} scorre tutti i candidati che al come descritto dall'istruzione 18 nel caso peggiore sono tutti i clienti, quindi complessità pari a  \emph{O(V)}. Il controllo 21 si accede costante con complessità \emph{O(1)} costante alla lista \textit{depotDistance} mentre la ricerca del massimo in  \textit{scannerRadius} richiede \emph{O(V)}. L'istruzione a riga 25 ritorna la massima distanza dal nodo \emph{c}, anche questa con complessità \emph{O(V)}. In riga 28 si scorrono i centrodi già trovati e quindi la complessità sarà compresa tra \emph{$O(TotDem) \leq O \leq O(V)$}, i 29 per controllare che \emph{c} non sia già all'interno della lista di centroidi la complessità è sempre \emph{$O(TotDem) \leq O \leq O(V)$}. Il controllo a riga 40 ha la stessa complessità di quello a riga13. La complessità totale è \emph{$O(V)$}
\end{itemize}

\subsubsection{General Assignement Problem solver}
Alla riga 6 si inizializza la lista \textit{allocCosts} con una complessità  pari a \emph{$O(V) \cdot O(k)$} con \emph{k} pari al numero di cluster e \emph{$ k \ll V $}. Alla riga 8 le domande dei cluster vengono inizializzate con complessità \emph{O(k)}. Alla riga 10 si calcolano i costi di allocazioni di ogni singolo clienti per ogni singolo cluster, la complessità è di nuovo  pari a \emph{$O(V) \cdot O(k)$}. Riga 13 il ciclo \texttt{for} scorre per tutta la sua lunghezza \textit{alloCosts} che nel caso peggiore è lungo \emph{$O(V)$} il secondo \emph{for} a riga 14 si occupa di scorrere i cluster la complessità di questi due cicli è di nuovo \emph{$O(V) \cdot O(k)$}. Il resto delle operazione richiede tempo costante \emph{O(1)}. La complessità totale è quindi \emph{$O(V \cdot k)$}.
\textbf{Ordine di allocamento di allocCost, infierisce sulla validità della soluzione, tutto dipende da quanti grassi clienti abbiamo}

\subsubsection{Routing}
 
\subsubsection{Nearest Neighbourn}
Alla riga 6 si scorrono tutti i cluster con complessità \emph{O(k)}, come già visto  \emph{$ k \ll V $}. Al suo interno  alla riga 8 si scorre la lista \textit{clusterAssignement} di lunghezza \emph{V}, con complessità \emph{O(V)} in totale questi due cicli \texttt{for} hanno complessità \emph{$O(V) \cdot O(k)$}.
L'istruzione \texttt{while} a riga 15 scorre \textit{cluster} per tutta la sua lunghezza che nel caso peggiore è \emph{V}, quindi \emph{O(V)}. Al suo interno alla riga 17 \textit{distPrevNode} contiene tutte le distanze dall'ultimo nodo aggiunto e il resto dei clienti esterni a \texttt{appoRoute} nel caso peggiore jha complessità \emph{O(V-1)}, alla riga 18 si ritorna l'indice minimo in \textit{distPrevNode} e di conseguenza si ritorna il corrispondente elemento in \textit{cluster}, con complessità \emph{O(V)}. Il controllo a riga 16 anch'esso ha complessità \emph{O(V)} nel caso peggiore. La complessità totale dell'algoritmo è 
\emph{$O(k \cdot V^3)$}. 
\textbf{Ovviamente la complessità nono sarà mai così alta perchè altrimenti non saremo in CVRP ma in un cammino hamiltoniano, e ci sarebbe un solo vicolo con capcità uglae alla soamm di tute l e domande. DI conseguenza la lungehzza di un cluster e di un veicolo e di una route, sarannno sicuramente minori comprese appunto tra  \emph{$TotDem \leq O \leq V/FatBoy$} }

\subsubsection{Nearest Neighbourn TrackPath}
Le righe 6 e 9 hanno complessità \emph{$O(V) \cdot O(k)$}. Alla riga 13 l'inizilizzazione di tutte le \emph{route} dal deposito al cliente richiede complessità complessità \emph{$O(V)$)}, alla riga  20 il sort di \textit{priorityQ} richiede anche'essa complessità \emph{$O(V)$)}. Il \texttt{while} in 22 scorre \textit{priorityQ} in  \emph{$O(V)$)}.
Da riga 27 a 30, si scorre \textit{cluster} e si controlla se il cliente è già presente nella \emph{shortRoute},  richiedendo   \emph{$O(V)$}, come già precisato \emph{shortRoute} contiene \emph{l < V} nodi quindi la complessità  è \emph{$O(V \cdot l)$}. In 33 \texttt{getNearestNeighbourn} richiede \emph{$O(V \setminus l)$}. Ala riga 47 si ordinano le le \emph{O(V)} \emph{route} e si estare la migliore in tempo costatante in riga 48. In totale l'algoritmo richiede \emph{$O(V \cdot l)$}.


\subsection{Route First, Cluster Second}
In riga 5 ogni elemento di \textit{dist} viene posto a $\infty$ richiedendo \emph{O(V)}, alla riga 8 si inizializza il grafo \textit{auxGraph} con una tupla per ogni vertice del \emph{V}, con complessità \emph{O(V)}. Alla riga 19 il \texttt{sort} della coda \textit{NodeQueue} richiede \emph{O(1)}, in quanto la coda detiene un solo elemento al momento.
Il \texttt{while} scorre tutta la coda con complessità asintotica \emph{$O(V^2)$} riga 21. Il \texttt{for} a riga 26 scorre tutti i vertici e al suo interno il for a riga 31 scorre i vertici tra il padre e il figlio l acomplessità dei due cilic innestati è \emph{$O(V^2)$}. Il \textbf{while} che ricompone il percorso dalla destinazione all'albero ha complessità \emph{O(H)} con \emph{H} uguale ai vertici in \textit{auxGraph}.La complessità totale è \emph{$O(V^2 \cdot H)$}.

\subsection{Algoritmo Genetico}
A riga 12 il \texttt{for} si occupa di costruire la popolazione di cromosomi iniziale con \emph{O(Npopulation)}. Al suo interno \emph{$K_clusterRand$} crea i centroidi con complessità \emph{O(Nvehicles)} riga 13. A riga 14 si esegue \texttt{GAPsolver} che abbiamo già detto avere complessità 
 \emph{$O(V \cdot k)$}, se questo va a buon fine  a riga 16  si esegue \texttt{NearestNeighbourn} che ha complessità \emph{DaRicalcolare}, in totale la costruzione della popolazione ha complessità \emph{Da Ricalcolare}. 
 Una volta che la popolazione è inizializzata, si passa al \texttt{while} a riga 22 che scorre le era a cui sottopone la popolazione in \emph{O(Eras)}. Al suo interno alla riga 26 il \texttt{for} esegue per un nuemero di volte uguale alla metà della popolazione le azioni necessarie per evolvere i cromosomi.
 Al suo interno alla riga 28, \texttt{Tournament} può avvenire con due modalità, \texttt{random}, sceglie due candidati a caso, ha complessità \emph{O(1)}; o con modalità \texttt{bestAndWorst} sceglie il migliore e il peggiore candidato, in questa modalità si richiede un ordinamento della popolazione, quindi richiede \emph{O(Npopulation)}. Alla riga 29 si passa all'istruzione \texttt{Crossover}, la quale scorre e incrocia i cromosomi candidati che contengono tutti i nodi visitati, in più ad ogni modifica ricalcola e il costo della soluzione per un totale di complessità pari a \emph{O($V^2$)}. In 32 \texttt{SearchAndCompleteSequence} cerca nella soluzione i clienti presenti e quelli non presenti con un costo \emph{O(V)}.A riga 42 il ciclo \texttt{for} scorre le \emph{route} all'interno della soluzione, chiamando di conseguenza \texttt{FlippingPath} eseguito in tempo costante \emph{O(1)} perchè scambia di posto due clienti random mutando il cromosoma. Richiedendo tempo \emph{O(R)} uguale al numero di \emph{route} nella soluzione.
 In 54 si riordina \textit{popEra} con complessità \emph{O$(\frac{Npopulation}{2})$}, si scelgono i migliori cromosomi di \textit{popEra} 55 e si sostituiscono  in 56 con complessità \emph{O$(best)$}. La complessità di questo grande ciclio è \emph{O($V^2$)}.
 Infine \textit{population} viene riordinato, la complessità rimane  \emph{O($V^2$)}.

\newpage
 
\section{Risultati}
 
Presentiamo qui i risultati di ogni algoritmo presentato 
\subsection{Clark and Wright}
\subsubsection{Sequenziale vs Parallelo}
\begin{tabular}{l l}
\small
			\begin{tabular}{||l | l l l l||} 
				\hline
				Istanza & Soluzione & Ottimo & Errore & Tempo \\ [0.5ex] 
				\hline\hline
				fri-n26-k3 & 1528.0 & 1353.0 & 0.1293 & 0.2897  \\
				bays-n29-k5 & 3126.0 & 2963.0 & 0.055 & 0.5512  \\
				hk-n48-k4 & 16582.0 & 14749.0 & 0.1243 & 3.6184  \\
				dantzig-n42-k4 & 1243.0 & 1142.0 & 0.0884 & 1.615  \\
				\rowcolor{red}
				ulysses-n22-k4 &  \cellcolor{red} 159142.0 & 40153.0 & 2.9634 &  \cellcolor{red}  0.145  \\
				\rowcolor{white}
				F-n135-k7 & 1423.0 & 1162.0 & 0.2246 & \cellcolor{yellow} 300.4521  \\
				gr-n17-k3 & 2819.0 & 2685.0 & 0.0499 & 0.0924  \\
				F-n72-k4 & 256.2 & 237.0 & 0.081 & \cellcolor{yellow} 13.701  \\
				gr-n24-k4 & 2178.0 & 2053.0 & 0.0609 & 0.2956  \\
				F-n45-k4 & 1003.1 & 724.0 & 0.3855 & 3.665  \\
				\rowcolor{red}
				ulysses-n16-k3 &  \cellcolor{red} 114975.0 & 30492.0 & 2.7707 &  \cellcolor{red}  0.0522  \\
				\rowcolor{white}
				swiss-n42-k5 & 1886.0 & 1668.0 & 0.1307 & 2.1471  \\
				gr-n48-k3 & 6975.0 & 5985.0 & 0.1654 & 3.1545  \\
				att-n48-k4 & 45947.5 & 40002.0 & 0.1486 & 3.5404  \\
				gr-n21-k3 & 4018.0 & 3704.0 & 0.0848 & 0.1598  \\
				bayg-n29-k4 & 2730.0 & 2050.0 & 0.3317 & 0.4739  \\
				\hline
				Media & 22864.49 & 9445.12 & 0.49 & 20.87  \\			
				[1ex] 
				\hline
			\end{tabular}

\small

			\begin{tabular}{||l | l l l l||} 
				\hline
				Istanza & Soluzione & Ottimo & Errore & Tempo \\ [0.5ex] 
				\hline\hline
				fri-n26-k3 & 1481.0 & 1353.0 & 0.0946 & 0.1044  \\
				bays-n29-k5 & 3126.0 & 2963.0 & 0.055 & 0.1404  \\
				hk-n48-k4 & 16393.0 & 14749.0 & 0.1115 & 0.6716  \\
				dantzig-n42-k4 & 1204.0 & 1142.0 & 0.0543 & 0.4504  \\
				\rowcolor{red}
				ulysses-n22-k4 &  \cellcolor{red} 159142.0 & 40153.0 & 2.9634 &  \cellcolor{red}  0.0631  \\
				\rowcolor{white}
				F-n135-k7 & 1219.3 & 1162.0 & 0.0493 & 36.6596  \\
				gr-n17-k3 & 2685.0 & 2685.0 &  \cellcolor{green} 0.0 & 0.0297  \\
				F-n72-k4 & 256.2 & 237.0 & 0.081 & 2.6585  \\
				gr-n24-k4 & 2178.0 & 2053.0 & 0.0609 & 0.0806  \\
				F-n45-k4 & 739.0 & 724.0 & 0.0207 & 0.5457  \\
				\rowcolor{red}
				ulysses-n16-k3 &  \cellcolor{red} 114975.0 & 30492.0 & 2.7707 &  \cellcolor{red} 0.0254  \\
				\rowcolor{white}
				swiss-n42-k5 & 1732.0 & 1668.0 & 0.0384 & 0.4569  \\
				gr-n48-k3 & 6743.0 & 5985.0 & 0.1266 & 0.6912  \\
				att-n48-k4 & 43477.4 & 40002.0 & 0.0869 & 0.6905  \\
				gr-n21-k3 & 4018.0 & 3704.0 & 0.0848 & 0.072  \\
				bayg-n29-k4 & 2730.0 & 2050.0 & 0.3317 & 0.1439  \\
				\hline
				Media & 22631.18 & 9445.12 & 0.43 & 2.72  \\
				[1ex] 
				\hline
			\end{tabular}


\end{tabular}

Questa tabella confronta i risultati ottenuti applicando l'algoritmo di Clark and Wright, nella tabella a sinistra l'algoritmo sequenziale entre nella tabella a destra quello parallelo. La colonna \texttt{Soluzione} in entrambe le tabelle differisce di ($\sim 200Km$), l'errore medio di (0,06) e il tempo medio di (20,87ms).
Vengono evidenziate in rosso le soluzioni trovate per le istanze \textit{ulysses-n22-k4} e \textit{ulysses-n16-k3} le soluzioni trovate da entrambi gli algoritmi hanno uno scarto di ($\sim 100.000 km$) presentando un errore di ($\sim 3$). Queste soluzioni sono state ricontrollate e lungo e si sospetta un bug all'interno della funzione che converte le coordinate \texttt{GEO}, non è stato però possibile rilevare il bug.
La seconda differenza importante che sottolinea la differenza tra i due metodi è evidenziata dalle istanza  \textit{F-n135-k7} e \textit{F-n72-k4} nella tabella sequenziale di sinistra, dove i tempi di esecuzione risultano essere $\sim 10$ volte più grandi rispetto ala tabella di destra che riguarda l'algoritmo parallelo.
Notare che un tempo di esecuzione più lungo non porta necessariamente ad una soluzione peggiore, come ad esempio im \textit{bays-n29-k5} il tempo di esecuzione è 5 volte maggiore nel sequenziale rispetto al parallelo, ma la soluzione trovata in termini di k di percorrenza è la medesima.
\subsection{Fisher and Jaikumar -Radius Radar Frontier}

\subsubsection{Nearest Neighbourn Routing vs Nearest Neighbourn Track Path }

\begin{tabular}{l l}
	\small	
		\begin{tabular}{||l | l l l l||} 
			\hline
			Istanza & Soluzione & Ottimo & Errore & Tempo \\ [0.5ex] 
			\hline\hline
		fri-n26-k3 & 1487.0 & 1353.0 & 0.099 & 0.0136  \\
		bays-n29-k5 & 3768.0 & 2963.0 & 0.2717 & 0.023  \\
		hk-n48-k4 & 19593.0 & 14749.0 & 0.3284 & 0.0335  \\
		dantzig-n42-k4 & 1503.0 & 1142.0 & 0.3161 & 0.025  \\
		ulysses-n22-k4 & 160871.0 & 40153.0 & 3.0065 & 0.0123  \\
		F-n135-k7 & 1784.7 & 1162.0 & 0.5359 & 0.1037  \\
		gr-n17-k3 & 3127.0 & 2685.0 & 0.1646 & 0.0088  \\
		F-n72-k4 & 364.6 & 237.0 & 0.5382 & 0.0611  \\
		gr-n24-k4 & 2667.0 & 2053.0 & 0.2991 & 0.0186  \\
		F-n45-k4 & 903.3 & 724.0 & 0.2476 & 0.0362  \\
		ulysses-n16-k3 & 116512.0 & 30492.0 & 2.8211 & 0.0089  \\
		swiss-n42-k5 & 2444.0 & 1668.0 & 0.4652 & 0.0312  \\
		gr-n48-k3 & 8836.0 & 5985.0 & 0.4764 & 0.0229  \\
		att-n48-k4 & 56257.5 & 40002.0 & 0.4064 & 0.0507  \\
		gr-n21-k3 & 5254.0 & 3704.0 & 0.4185 & 0.0131  \\
		bayg-n29-k4 & 3435.0 & 2050.0 & 0.6756 & 0.0151  \\
		\hline
		Media & 24300.44 & 9445.12 & 0.69 & 0.03  \\		
			[1ex] 
			\hline
		\end{tabular}

\small		
	\begin{tabular}{||l | l l l l||} 
		\hline
		Istanza & Soluzione & Ottimo & Errore & Tempo \\ [0.5ex] 
		\hline\hline
		fri-n26-k3 & 1405.0 & 1353.0 & 0.0384 & 0.0423  \\
		bays-n29-k5 & 3715.0 & 2963.0 & 0.2538 & 0.0402  \\
		hk-n48-k4 & 19000.0 & 14749.0 & 0.2882 & 0.1211  \\
		dantzig-n42-k4 & 1492.0 & 1142.0 & 0.3065 & 0.0806  \\
		ulysses-n22-k4 & 160699.0 & 40153.0 & 3.0022 & 0.0241  \\
		F-n135-k7 & 1769.1 & 1162.0 & 0.5224 & 0.818  \\
		gr-n17-k3 & 3127.0 & 2685.0 & 0.1646 & 0.0189  \\
		F-n72-k4 & 338.8 & 237.0 & 0.4297 & 0.3485  \\
		gr-n24-k4 & 2599.0 & 2053.0 & 0.266 & 0.0339  \\
		F-n45-k4 & 893.1 & 724.0 & 0.2336 & 0.1501  \\
		ulysses-n16-k3 & 116342.0 & 30492.0 & 2.8155 & 0.0166  \\
		swiss-n42-k5 & 2327.0 & 1668.0 & 0.3951 & 0.0721  \\
		gr-n48-k3 & 8474.0 & 5985.0 & 0.4159 & 0.1383  \\
		att-n48-k4 & 53118.4 & 40002.0 & 0.3279 & 0.1391  \\
		gr-n21-k3 & 5249.0 & 3704.0 & 0.4171 & 0.0285  \\
		bayg-n29-k4 & 2871.0 & 2050.0 & 0.4005 & 0.0395  \\
		\hline
		Media & 23963.71 & 9445.12 & 0.64 & 0.13  \\			
		[1ex] 
		\hline

	\end{tabular}
	
\end{tabular}



\subsection{Fisher and Jaikumar - Random Centroid}

\subsubsection{Nearest Neighbourn Routing vs Nearest Neighbourn Track Path }

\begin{tabular}{l l}
	\small	
	\begin{tabular}{||l | l l l l||} 
		\hline
		Istanza & Soluzione & Ottimo & Errore & Tempo \\ [0.5ex] 
		\hline\hline
		fri-n26-k3 & 1487.0 & 1353.0 & 0.099 & 0.0099  \\
		bays-n29-k5 & 3540.0 & 2963.0 & 0.1947 & 0.0103  \\
		hk-n48-k4 & 21537.0 & 14749.0 & 0.4602 & 0.0163  \\
		dantzig-n42-k4 & 1319.0 & 1142.0 & 0.155 & 0.0128  \\
		ulysses-n22-k4 & 160838.0 & 40153.0 & 3.0056 & 0.0084  \\
		F-n135-k7 & 2081.0 & 1162.0 & 0.7909 & 0.0557  \\
		gr-n17-k3 & 3360.0 & 2685.0 & 0.2514 & 0.0059  \\
		F-n72-k4 & 440.9 & 237.0 & 0.8602 & 0.0214  \\
		gr-n24-k4 & 3087.0 & 2053.0 & 0.5037 & 0.0106  \\
		F-n45-k4 & 1120.2 & 724.0 & 0.5473 & 0.0137  \\
		ulysses-n16-k3 & 115946.0 & 30492.0 & 2.8025 & 0.006  \\
		swiss-n42-k5 & 2688.0 & 1668.0 & 0.6115 & 0.0151  \\
		gr-n48-k3 & 7606.0 & 5985.0 & 0.2708 & 0.0128  \\
		att-n48-k4 & 64478.2 & 40002.0 & 0.6119 & 0.0153  \\
		gr-n21-k3 & 4370.0 & 3704.0 & 0.1798 & 0.0068  \\
		bayg-n29-k4 & 3260.0 & 2050.0 & 0.5902 & 0.0139  \\
		\hline
		Media & 24822.39 & 9445.12 & 0.75 & 0.01  \\			
		[1ex] 
		\hline
	\end{tabular}
	
	\small		
	\begin{tabular}{||l | l l l l||} 
		\hline
		Istanza & Soluzione & Ottimo & Errore & Tempo \\ [0.5ex] 
		\hline\hline
		fri-n26-k3 & 1405.0 & 1353.0 & 0.0384 & 0.038  \\
		bays-n29-k5 & 3404.0 & 2963.0 & 0.1488 & 0.0272  \\
		hk-n48-k4 & 20546.0 & 14749.0 & 0.393 & 0.1055  \\
		dantzig-n42-k4 & 1253.0 & 1142.0 & 0.0972 & 0.0683  \\
		ulysses-n22-k4 & 160544.0 & 40153.0 & 2.9983 & 0.02  \\
		F-n135-k7 & 2015.8 & 1162.0 & 0.7348 & 0.7298  \\
		gr-n17-k3 & 3329.0 & 2685.0 & 0.2399 & 0.0147  \\
		F-n72-k4 & 413.4 & 237.0 & 0.7444 & 0.2836  \\
		gr-n24-k4 & 2833.0 & 2053.0 & 0.3799 & 0.0276  \\
		F-n45-k4 & 1103.9 & 724.0 & 0.5247 & 0.0902  \\
		ulysses-n16-k3 & 115796.0 & 30492.0 & 2.7976 & 0.0135  \\
		swiss-n42-k5 & 2579.0 & 1668.0 & 0.5462 & 0.0581  \\
		gr-n48-k3 & 7489.0 & 5985.0 & 0.2513 & 0.1282  \\
		att-n48-k4 & 62530.5 & 40002.0 & 0.5632 & 0.11  \\
		gr-n21-k3 & 4210.0 & 3704.0 & 0.1366 & 0.0219  \\
		bayg-n29-k4 & 3012.0 & 2050.0 & 0.4693 & 0.0374  \\
		\hline
		Media & 24528.97 & 9445.12 & 0.69 & 0.11  \\	
		[1ex] 
		\hline
	\end{tabular}
	
\end{tabular}




\subsection{Route First, Cluster Second}

\begin{table}[h!]
	\begin{center}	
		\begin{tabular}{||l | l l l l||} 
			\hline
			Istanza & Soluzione & Ottimo & Errore & Tempo \\ [0.5ex] 
			\hline\hline
		fri-n26-k3 & 1805.0 & 1353.0 & 0.3341 & 0.0698  \\
		bays-n29-k5 & 6659.0 & 2963.0 & 1.2474 & 0.0496  \\
		hk-n48-k4 & 49978.0 & 14749.0 & 2.3886 & 0.3247  \\
		dantzig-n42-k4 & 1388.0 & 1142.0 & 0.2154 & 0.2074  \\
		ulysses-n22-k4 & 179670.0 & 40153.0 & 3.4746 & 0.0326  \\
		F-n135-k7 & 2417.3 & 1162.0 & 1.0803 & 3.9207  \\
		gr-n17-k3 & 5275.0 & 2685.0 & 0.9646 & 0.0215  \\
		F-n72-k4 & 561.8 & 237.0 & 1.3703 & 1.6613  \\
		gr-n24-k4 & 4021.0 & 2053.0 & 0.9586 & 0.0351  \\
		F-n45-k4 & 1384.2 & 724.0 & 0.9119 & 0.1982  \\
		ulysses-n16-k3 & 122313.0 & 30492.0 & 3.0113 & 0.0149  \\
		swiss-n42-k5 & 3238.0 & 1668.0 & 0.9412 & 0.1768  \\
		gr-n48-k3 & 21626.0 & 5985.0 & 2.6134 & 0.4474  \\
		att-n48-k4 & 172814.2 & 40002.0 & 3.3201 & 0.6002  \\
		gr-n21-k3 & 7634.0 & 3704.0 & 1.061 & 0.0411  \\
		bayg-n29-k4 & 5287.0 & 2050.0 & 1.579 & 0.0854  \\
		\hline
		Media & 36629.47 & 9445.12 & 1.59 & 0.49  \\	
			[1ex] 
			\hline
		\end{tabular}
	\end{center}
\end{table}

\subsection{Algoritmo Genetico}

\begin{table}[h!]
	\begin{center}	
		\begin{tabular}{||l | l l l l||} 
			\hline
			Istanza & Soluzione & Ottimo & Errore & Tempo \\ [0.5ex] 
			\hline\hline
			fri-n26-k3 & 1805.0 & 1353.0 & 0.3341 & 0.0201  \\
			bays-n29-k5 & 6659.0 & 2963.0 & 1.2474 & 0.0139  \\
			hk-n48-k4 & 49978.0 & 14749.0 & 2.3886 & 0.1101  \\
			dantzig-n42-k4 & 1388.0 & 1142.0 & 0.2154 & 0.0555  \\
			ulysses-n22-k4 & 179670.0 & 40153.0 & 3.4746 & 0.0065  \\
			F-n135-k7 & 2417.3 & 1162.0 & 1.0803 & 0.7319  \\
			gr-n17-k3 & 5275.0 & 2685.0 & 0.9646 & 0.0055  \\
			F-n72-k4 & 561.8 & 237.0 & 1.3703 & 0.3878  \\
			gr-n24-k4 & 4021.0 & 2053.0 & 0.9586 & 0.0099  \\
			F-n45-k4 & 1384.2 & 724.0 & 0.9119 & 0.0682  \\
			ulysses-n16-k3 & 122313.0 & 30492.0 & 3.0113 & 0.0033  \\
			swiss-n42-k5 & 3238.0 & 1668.0 & 0.9412 & 0.0453  \\
			gr-n48-k3 & 21626.0 & 5985.0 & 2.6134 & 0.1095  \\
			att-n48-k4 & 172814.2 & 40002.0 & 3.3201 & 0.161  \\
			gr-n21-k3 & 7634.0 & 3704.0 & 1.061 & 0.0098  \\
			bayg-n29-k4 & 5287.0 & 2050.0 & 1.579 & 0.0251  \\		
			[1ex] 
			\hline
		\end{tabular}
	\end{center}
\end{table}

\bibliographystyle{unsrt}
\bibliography{biblio}


\end{document}









